// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: playlists.sql

package repository

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createPlaylist = `-- name: CreatePlaylist :one
INSERT INTO playlists (playlist_id, playlist_name, owner_id, is_public)
VALUES ($1, $2, $3, $4)
RETURNING playlist_id, playlist_name, owner_id, is_public, created_at, updated_at
`

type CreatePlaylistParams struct {
	PlaylistID   uuid.UUID   `json:"playlist_id"`
	PlaylistName pgtype.Text `json:"playlist_name"`
	OwnerID      uuid.UUID   `json:"owner_id"`
	IsPublic     pgtype.Bool `json:"is_public"`
}

func (q *Queries) CreatePlaylist(ctx context.Context, arg CreatePlaylistParams) (Playlist, error) {
	row := q.db.QueryRow(ctx, createPlaylist,
		arg.PlaylistID,
		arg.PlaylistName,
		arg.OwnerID,
		arg.IsPublic,
	)
	var i Playlist
	err := row.Scan(
		&i.PlaylistID,
		&i.PlaylistName,
		&i.OwnerID,
		&i.IsPublic,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deletePlaylist = `-- name: DeletePlaylist :exec
DELETE FROM playlists
WHERE playlist_id = $1
`

func (q *Queries) DeletePlaylist(ctx context.Context, playlistID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deletePlaylist, playlistID)
	return err
}

const getPlaylistById = `-- name: GetPlaylistById :one
SELECT playlist_id, playlist_name, owner_id, is_public, created_at, updated_at
FROM playlists
WHERE playlist_id = $1
`

func (q *Queries) GetPlaylistById(ctx context.Context, playlistID uuid.UUID) (Playlist, error) {
	row := q.db.QueryRow(ctx, getPlaylistById, playlistID)
	var i Playlist
	err := row.Scan(
		&i.PlaylistID,
		&i.PlaylistName,
		&i.OwnerID,
		&i.IsPublic,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPlaylistWithSongs = `-- name: GetPlaylistWithSongs :many
SELECT 
    p.playlist_id,
    p.playlist_name,
    p.owner_id,
    p.is_public,
    p.created_at,
    p.updated_at,
    ps.song_id,
    ps.position,
    s.title,
    s.title_token,
    s.categories
FROM playlists p
LEFT JOIN playlist_song ps ON p.playlist_id = ps.playlist_id
LEFT JOIN songs s ON ps.song_id = s.id
WHERE p.playlist_id = $1
ORDER BY ps.position ASC
`

type GetPlaylistWithSongsRow struct {
	PlaylistID   uuid.UUID        `json:"playlist_id"`
	PlaylistName pgtype.Text      `json:"playlist_name"`
	OwnerID      uuid.UUID        `json:"owner_id"`
	IsPublic     pgtype.Bool      `json:"is_public"`
	CreatedAt    pgtype.Timestamp `json:"created_at"`
	UpdatedAt    pgtype.Timestamp `json:"updated_at"`
	SongID       pgtype.Text      `json:"song_id"`
	Position     pgtype.Int4      `json:"position"`
	Title        pgtype.Text      `json:"title"`
	TitleToken   []string         `json:"title_token"`
	Categories   []string         `json:"categories"`
}

func (q *Queries) GetPlaylistWithSongs(ctx context.Context, playlistID uuid.UUID) ([]GetPlaylistWithSongsRow, error) {
	rows, err := q.db.Query(ctx, getPlaylistWithSongs, playlistID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPlaylistWithSongsRow{}
	for rows.Next() {
		var i GetPlaylistWithSongsRow
		if err := rows.Scan(
			&i.PlaylistID,
			&i.PlaylistName,
			&i.OwnerID,
			&i.IsPublic,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SongID,
			&i.Position,
			&i.Title,
			&i.TitleToken,
			&i.Categories,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlaylistWithSongsAndArtists = `-- name: GetPlaylistWithSongsAndArtists :many
SELECT 
    p.playlist_id,
    p.playlist_name,
    p.owner_id,
    p.is_public,
    p.created_at,
    p.updated_at,
    ps.song_id,
    ps.position,
    s.title,
    a.id AS artist_id,
    a.name AS artist_name
FROM playlists p
LEFT JOIN playlist_song ps ON p.playlist_id = ps.playlist_id
LEFT JOIN songs s ON ps.song_id = s.id
LEFT JOIN artist_songs sa ON s.id = sa.song_id
LEFT JOIN artists a ON sa.artist_id = a.id
WHERE p.playlist_id = $1
ORDER BY ps.position ASC, a.name ASC
`

type GetPlaylistWithSongsAndArtistsRow struct {
	PlaylistID   uuid.UUID        `json:"playlist_id"`
	PlaylistName pgtype.Text      `json:"playlist_name"`
	OwnerID      uuid.UUID        `json:"owner_id"`
	IsPublic     pgtype.Bool      `json:"is_public"`
	CreatedAt    pgtype.Timestamp `json:"created_at"`
	UpdatedAt    pgtype.Timestamp `json:"updated_at"`
	SongID       pgtype.Text      `json:"song_id"`
	Position     pgtype.Int4      `json:"position"`
	Title        pgtype.Text      `json:"title"`
	ArtistID     pgtype.Int4      `json:"artist_id"`
	ArtistName   pgtype.Text      `json:"artist_name"`
}

func (q *Queries) GetPlaylistWithSongsAndArtists(ctx context.Context, playlistID uuid.UUID) ([]GetPlaylistWithSongsAndArtistsRow, error) {
	rows, err := q.db.Query(ctx, getPlaylistWithSongsAndArtists, playlistID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPlaylistWithSongsAndArtistsRow{}
	for rows.Next() {
		var i GetPlaylistWithSongsAndArtistsRow
		if err := rows.Scan(
			&i.PlaylistID,
			&i.PlaylistName,
			&i.OwnerID,
			&i.IsPublic,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SongID,
			&i.Position,
			&i.Title,
			&i.ArtistID,
			&i.ArtistName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSongsInPlaylist = `-- name: GetSongsInPlaylist :many
SELECT 
    ps.song_id,
    ps.position,
    s.title,
    s.title_token,
    s.categories
FROM playlist_song ps
JOIN songs s ON ps.song_id = s.id
WHERE ps.playlist_id = $1
ORDER BY ps.position ASC
`

type GetSongsInPlaylistRow struct {
	SongID     string   `json:"song_id"`
	Position   int32    `json:"position"`
	Title      string   `json:"title"`
	TitleToken []string `json:"title_token"`
	Categories []string `json:"categories"`
}

func (q *Queries) GetSongsInPlaylist(ctx context.Context, playlistID uuid.UUID) ([]GetSongsInPlaylistRow, error) {
	rows, err := q.db.Query(ctx, getSongsInPlaylist, playlistID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetSongsInPlaylistRow{}
	for rows.Next() {
		var i GetSongsInPlaylistRow
		if err := rows.Scan(
			&i.SongID,
			&i.Position,
			&i.Title,
			&i.TitleToken,
			&i.Categories,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMyPlaylists = `-- name: ListMyPlaylists :many
SELECT playlist_id, playlist_name, owner_id, is_public, created_at, updated_at
FROM playlists
WHERE owner_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListMyPlaylists(ctx context.Context, ownerID uuid.UUID) ([]Playlist, error) {
	rows, err := q.db.Query(ctx, listMyPlaylists, ownerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Playlist{}
	for rows.Next() {
		var i Playlist
		if err := rows.Scan(
			&i.PlaylistID,
			&i.PlaylistName,
			&i.OwnerID,
			&i.IsPublic,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMyPlaylistsWithSongsAndArtists = `-- name: ListMyPlaylistsWithSongsAndArtists :many
SELECT 
    p.playlist_id,
    p.playlist_name,
    p.owner_id,
    p.is_public,
    ps.song_id,
    ps.position,
    s.title,
    a.id AS artist_id,
    a.name AS artist_name
FROM playlists p
LEFT JOIN playlist_song ps ON p.playlist_id = ps.playlist_id
LEFT JOIN songs s ON ps.song_id = s.id
LEFT JOIN artist_songs sa ON s.id = sa.song_id
LEFT JOIN artists a ON sa.artist_id = a.id
WHERE p.owner_id = $1
ORDER BY p.created_at DESC, ps.position ASC, a.name ASC
`

type ListMyPlaylistsWithSongsAndArtistsRow struct {
	PlaylistID   uuid.UUID   `json:"playlist_id"`
	PlaylistName pgtype.Text `json:"playlist_name"`
	OwnerID      uuid.UUID   `json:"owner_id"`
	IsPublic     pgtype.Bool `json:"is_public"`
	SongID       pgtype.Text `json:"song_id"`
	Position     pgtype.Int4 `json:"position"`
	Title        pgtype.Text `json:"title"`
	ArtistID     pgtype.Int4 `json:"artist_id"`
	ArtistName   pgtype.Text `json:"artist_name"`
}

func (q *Queries) ListMyPlaylistsWithSongsAndArtists(ctx context.Context, ownerID uuid.UUID) ([]ListMyPlaylistsWithSongsAndArtistsRow, error) {
	rows, err := q.db.Query(ctx, listMyPlaylistsWithSongsAndArtists, ownerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListMyPlaylistsWithSongsAndArtistsRow{}
	for rows.Next() {
		var i ListMyPlaylistsWithSongsAndArtistsRow
		if err := rows.Scan(
			&i.PlaylistID,
			&i.PlaylistName,
			&i.OwnerID,
			&i.IsPublic,
			&i.SongID,
			&i.Position,
			&i.Title,
			&i.ArtistID,
			&i.ArtistName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPlaylists = `-- name: ListPlaylists :many
SELECT playlist_id, playlist_name, owner_id, is_public, created_at, updated_at
FROM playlists
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListPlaylistsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListPlaylists(ctx context.Context, arg ListPlaylistsParams) ([]Playlist, error) {
	rows, err := q.db.Query(ctx, listPlaylists, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Playlist{}
	for rows.Next() {
		var i Playlist
		if err := rows.Scan(
			&i.PlaylistID,
			&i.PlaylistName,
			&i.OwnerID,
			&i.IsPublic,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePlaylist = `-- name: UpdatePlaylist :one
UPDATE playlists
SET playlist_name = $2, is_public = $3, updated_at = now()
WHERE playlist_id = $1
RETURNING playlist_id, playlist_name, owner_id, is_public, created_at, updated_at
`

type UpdatePlaylistParams struct {
	PlaylistID   uuid.UUID   `json:"playlist_id"`
	PlaylistName pgtype.Text `json:"playlist_name"`
	IsPublic     pgtype.Bool `json:"is_public"`
}

func (q *Queries) UpdatePlaylist(ctx context.Context, arg UpdatePlaylistParams) (Playlist, error) {
	row := q.db.QueryRow(ctx, updatePlaylist, arg.PlaylistID, arg.PlaylistName, arg.IsPublic)
	var i Playlist
	err := row.Scan(
		&i.PlaylistID,
		&i.PlaylistName,
		&i.OwnerID,
		&i.IsPublic,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
